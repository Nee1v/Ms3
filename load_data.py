import sqlite3
import csv
import os

DB_FILE = "library.db"

# A mapping of CSV filenames to their corresponding table name
# and the SQL INSERT query.
# This assumes your CSV columns are in the same order as the table schema.
CSV_FILES_TO_TABLES = {
    'book.csv': {
        'table': 'BOOK',
        'sql': 'INSERT INTO BOOK (Isbn, Title) VALUES (?, ?)'
    },
    'authors.csv': {
        'table': 'AUTHORS',
        'sql': 'INSERT INTO AUTHORS (Author_id, Name) VALUES (?, ?)'
    },
    'book_authors.csv': {
        'table': 'BOOK_AUTHORS',
        'sql': 'INSERT INTO BOOK_AUTHORS (Author_id, Isbn) VALUES (?, ?)'
    },
    'borrower.csv': {
        'table': 'BORROWER',
        'sql': 'INSERT INTO BORROWER (Card_id, Ssn, Bname, Address, Phone) VALUES (?, ?, ?, ?, ?)'
    }
    # We don't load BOOK_LOANS or FINES, as that data
    # will be generated by the application.
}


def load_data():
    """
    Loads data from normalized CSV files into the SQLite database.
    """
    if not os.path.exists(DB_FILE):
        print(f"Error: Database file '{DB_FILE}' not found.")
        print("Please run the 'create_db.py' script first.")
        return

    conn = None
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Enable foreign key enforcement
        cursor.execute("PRAGMA foreign_keys = ON;")

        print("Starting data load...")

        for filename, info in CSV_FILES_TO_TABLES.items():

            if not os.path.exists(filename):
                print(f"  [!] Warning: File '{filename}' not found. Skipping.")
                continue

            try:
                with open(filename, 'r', encoding='utf-8-sig') as file:
                    # 'utf-8-sig' handles potential BOM (Byte Order Mark)

                    reader = csv.reader(file)

                    # Skip the header row
                    header = next(reader, None)
                    if header is None:
                        print(f"  [*] Skipping empty file: {filename}")
                        continue

                    # Read all remaining data into a list
                    data = list(reader)

                    if not data:
                        print(f"  [*] No data found in {filename} (after header).")
                        continue

                    # Use executemany for fast bulk insertion
                    cursor.executemany(info['sql'], data)

                    print(f"  [+] Successfully loaded {len(data)} rows into {info['table']}.")

            except Exception as e:
                print(f"  [!] FAILED to load {filename}. Error: {e}")
                print("      Rolling back changes...")
                conn.rollback()  # Rollback changes for this file
                return  # Stop the script on failure
            
        # After borrowers are loaded, create USERS rows for each borrower
        # username = Card_id, password = Ssn, card_id = Card_id, is_librarian = 0
        cursor.execute("""
            INSERT INTO USERS (username, password, card_id, is_librarian)
            SELECT Card_id, Ssn, Card_id, 0
            FROM BORROWER;
        """)

        # If all files loaded successfully, commit the changes
        conn.commit()
        print("\nSuccess! All data has been loaded and committed to the database.")

    except sqlite3.Error as e:
        print(f"\nAn error occurred with the database: {e}")
        if conn:
            conn.rollback()
            print("All changes have been rolled back.")
    finally:
        if conn:
            conn.close()


if __name__ == "__main__":
    load_data()